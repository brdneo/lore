#!/usr/bin/env python3
"""
An√°lise Completa de Robustez e Ader√™ncia ao Roadmap - Lore N.A.
===============================================================

Este script faz uma an√°lise detalhada para responder:
1. Todas as ideias da documenta√ß√£o est√£o implementadas?
2. O universo √© robusto o suficiente para evoluir 24/7?
3. √â poss√≠vel expandir o c√≥digo enquanto o universo roda?
4. Quais s√£o os pontos fracos que precisam ser fortalecidos?

Autor: Lore N.A. Analysis Team
Data: 2025
"""

import os
import sys
import json
import ast
import importlib.util
from pathlib import Path
from typing import Dict, List, Tuple, Any
import logging
from datetime import datetime

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class RobustezAnalyzer:
    """Analisador de robustez e ader√™ncia ao roadmap"""

    def __init__(self, project_root: str = "/home/brendo/lore"):
        self.project_root = Path(project_root)
        self.src_dir = self.project_root / "src"
        self.docs_dir = self.project_root / "docs"

        # An√°lise de implementa√ß√£o
        self.implemented_features = []
        self.missing_features = []
        self.robustez_issues = []
        self.expansion_blockers = []

    def analyze_roadmap_implementation(self) -> Dict[str, Any]:
        """Analisa ader√™ncia ao roadmap dos PROXIMOS-PASSOS.md"""

        print("üîç AN√ÅLISE DE ADER√äNCIA AO ROADMAP")
        print("=" * 50)

        # Funcionalidades esperadas do roadmap
        expected_features = {
            # FASE 1: CONSOLIDA√á√ÉO - STATUS ESPERADO: IMPLEMENTADO
            "genesis_protocol": {
                "description": "Sistema de DNA Digital Completo",
                "files": ["agent_dna.py", "evolved_agent.py"],
                "status": "unknown"
            },
            "identity_system": {
                "description": "Sistema de Identidades √önicas",
                "files": ["agent_name_generator.py", "base_agent.py"],
                "status": "unknown"
            },
            "neural_network": {
                "description": "Rede Social Neural",
                "files": ["neural_web.py", "social_network_manager.py"],
                "status": "unknown"
            },
            "evolution_engine": {
                "description": "Motor de Evolu√ß√£o",
                "files": ["agent_dna.py", "population_manager.py"],
                "status": "unknown"
            },
            "api_server": {
                "description": "API Server (FastAPI)",
                "files": ["api_server.py"],
                "status": "unknown"
            },
            "dashboard": {
                "description": "Dashboard visual (Streamlit)",
                "files": ["dashboard.py"],
                "status": "unknown"
            },
            "emotional_economy": {
                "description": "Sistema de economia emocional",
                "files": ["emotional_economy.py"],
                "status": "unknown"
            },

            # FUNCIONALIDADES AVAN√áADAS - STATUS ESPERADO: EM DESENVOLVIMENTO
            "performance_optimization": {
                "description": "Otimiza√ß√£o de Performance",
                "files": ["async", "caching", "parallel_processing"],
                "status": "unknown"
            },
            "robustness": {
                "description": "Robustez do Sistema",
                "files": ["error_handling", "structured_logs", "automated_tests"],
                "status": "unknown"
            },
            "analytics": {
                "description": "Analytics Avan√ßadas",
                "files": ["behavioral_metrics", "trend_analysis", "predictions"],
                "status": "unknown"
            },
            "ai_conversational": {
                "description": "IA Conversacional",
                "files": ["language_models", "memory_system", "learning"],
                "status": "unknown"
            },
            "digital_democracy": {
                "description": "Governo Digital Democr√°tico",
                "files": ["voting_system", "consensus", "leadership_hierarchy"],
                "status": "unknown"
            },
            "persistent_distributed": {
                "description": "Persist√™ncia Distribu√≠da",
                "files": ["database_manager", "backup_system", "synchronization"],
                "status": "unknown"
            }
        }

        # Verificar implementa√ß√£o de cada feature
        for feature_name, feature_info in expected_features.items():
            print(f"\nüîé Analisando: {feature_info['description']}")

            if isinstance(feature_info['files'], list) and len(feature_info['files']) > 0:
                if isinstance(feature_info['files'][0], str) and feature_info['files'][0].endswith('.py'):
                    # Arquivos espec√≠ficos
                    implemented_files = []
                    missing_files = []

                    for file_name in feature_info['files']:
                        file_path = self.src_dir / file_name
                        if file_path.exists():
                            implemented_files.append(file_name)
                            # Analisar complexidade do arquivo
                            complexity = self._analyze_file_complexity(file_path)
                            print(f"   ‚úÖ {file_name} - {complexity['lines']} linhas, {complexity['functions']} fun√ß√µes")
                        else:
                            missing_files.append(file_name)
                            print(f"   ‚ùå {file_name} - AUSENTE")

                    if len(implemented_files) == len(feature_info['files']):
                        feature_info['status'] = "implemented"
                        self.implemented_features.append(feature_name)
                    elif len(implemented_files) > 0:
                        feature_info['status'] = "partial"
                        print("   ‚ö†Ô∏è Implementa√ß√£o PARCIAL")
                    else:
                        feature_info['status'] = "missing"
                        self.missing_features.append(feature_name)
                else:
                    # Conceitos abstratos (async, caching, etc.)
                    concept_found = self._search_concept_in_codebase(feature_info['files'])
                    if concept_found:
                        feature_info['status'] = "partial"
                        print("   ‚ö†Ô∏è Conceito encontrado PARCIALMENTE no c√≥digo")
                    else:
                        feature_info['status'] = "missing"
                        self.missing_features.append(feature_name)
                        print("   ‚ùå Conceito N√ÉO encontrado no c√≥digo")

        return expected_features

    def analyze_robustness(self) -> Dict[str, Any]:
        """Analisa robustez do sistema para execu√ß√£o 24/7"""

        print("\n\nüõ°Ô∏è AN√ÅLISE DE ROBUSTEZ 24/7")
        print("=" * 50)

        robustness_criteria = {
            "error_handling": {
                "description": "Tratamento de erros abrangente",
                "score": 0,
                "issues": []
            },
            "logging": {
                "description": "Sistema de logs estruturado",
                "score": 0,
                "issues": []
            },
            "monitoring": {
                "description": "Monitoramento e health checks",
                "score": 0,
                "issues": []
            },
            "graceful_shutdown": {
                "description": "Shutdown gracioso",
                "score": 0,
                "issues": []
            },
            "resource_management": {
                "description": "Gest√£o de recursos e mem√≥ria",
                "score": 0,
                "issues": []
            },
            "database_reliability": {
                "description": "Confiabilidade de banco de dados",
                "score": 0,
                "issues": []
            },
            "concurrent_safety": {
                "description": "Seguran√ßa em concorr√™ncia",
                "score": 0,
                "issues": []
            }
        }

        # Analisar cada arquivo Python
        python_files = list(self.src_dir.glob("*.py"))

        for py_file in python_files:
            print(f"\nüîç Analisando robustez: {py_file.name}")

            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                # An√°lise de tratamento de erros
                try_except_count = content.count('try:')
                if try_except_count > 0:
                    robustness_criteria["error_handling"]["score"] += 1
                    print(f"   ‚úÖ {try_except_count} blocos try/except encontrados")
                else:
                    robustness_criteria["error_handling"]["issues"].append(f"{py_file.name}: Sem tratamento de erros")
                    print("   ‚ùå Nenhum tratamento de erro encontrado")

                # An√°lise de logging
                if 'logging' in content or 'logger' in content:
                    robustness_criteria["logging"]["score"] += 1
                    print("   ‚úÖ Sistema de logging implementado")
                else:
                    robustness_criteria["logging"]["issues"].append(f"{py_file.name}: Sem logging")
                    print("   ‚ùå Sem sistema de logging")

                # An√°lise de async/await
                if 'async de' in content or 'await' in content:
                    robustness_criteria["concurrent_safety"]["score"] += 1
                    print("   ‚úÖ C√≥digo ass√≠ncrono encontrado")

                # An√°lise de graceful shutdown
                if 'signal' in content or 'SIGINT' in content or 'SIGTERM' in content:
                    robustness_criteria["graceful_shutdown"]["score"] += 1
                    print("   ‚úÖ Graceful shutdown implementado")

            except Exception as e:
                print(f"   ‚ö†Ô∏è Erro ao analisar {py_file.name}: {e}")

        # Calcular score geral de robustez
        total_files = len(python_files)
        for criterion in robustness_criteria.values():
            if total_files > 0:
                criterion["percentage"] = (criterion["score"] / total_files) * 100
            else:
                criterion["percentage"] = 0

        return robustness_criteria

    def analyze_expansion_capability(self) -> Dict[str, Any]:
        """Analisa capacidade de expans√£o enquanto roda"""

        print("\n\nüöÄ AN√ÅLISE DE CAPACIDADE DE EXPANS√ÉO")
        print("=" * 50)

        expansion_factors = {
            "hot_reload": {
                "description": "Capacidade de hot reload",
                "implemented": False,
                "blockers": []
            },
            "modular_architecture": {
                "description": "Arquitetura modular",
                "implemented": False,
                "blockers": []
            },
            "database_migrations": {
                "description": "Sistema de migra√ß√µes de banco",
                "implemented": False,
                "blockers": []
            },
            "api_versioning": {
                "description": "Versionamento de API",
                "implemented": False,
                "blockers": []
            },
            "plugin_system": {
                "description": "Sistema de plugins",
                "implemented": False,
                "blockers": []
            },
            "configuration_reload": {
                "description": "Reload de configura√ß√£o",
                "implemented": False,
                "blockers": []
            }
        }

        # Verificar arquitetura modular
        src_dirs = [d for d in self.src_dir.iterdir() if d.is_dir()]
        if len(src_dirs) >= 3:  # api, core, models, utils, web
            expansion_factors["modular_architecture"]["implemented"] = True
            print("‚úÖ Arquitetura modular detectada")
        else:
            expansion_factors["modular_architecture"]["blockers"].append("Estrutura monol√≠tica")
            print("‚ùå Arquitetura n√£o √© suficientemente modular")

        # Verificar sistema de migra√ß√µes
        migration_indicators = ['migrate', 'schema', 'alembic', 'version']
        database_file = self.src_dir / "database_manager.py"
        if database_file.exists():
            with open(database_file, 'r') as f:
                content = f.read().lower()
                if any(indicator in content for indicator in migration_indicators):
                    expansion_factors["database_migrations"]["implemented"] = True
                    print("‚úÖ Sistema de migra√ß√µes detectado")
                else:
                    expansion_factors["database_migrations"]["blockers"].append("Sem sistema de migra√ß√µes")
                    print("‚ùå Sem sistema de migra√ß√µes de banco")

        # Verificar API versioning
        api_file = self.src_dir / "api_server.py"
        if api_file.exists():
            with open(api_file, 'r') as f:
                content = f.read().lower()
                if 'v1' in content or 'version' in content or '/api/' in content:
                    expansion_factors["api_versioning"]["implemented"] = True
                    print("‚úÖ Versionamento de API detectado")
                else:
                    expansion_factors["api_versioning"]["blockers"].append("API sem versionamento")
                    print("‚ùå API sem versionamento")

        return expansion_factors

    def generate_comprehensive_report(self) -> str:
        """Gera relat√≥rio completo de an√°lise"""

        print("\n\nüìä EXECUTANDO AN√ÅLISE COMPLETA...")
        print("=" * 60)

        # Executar todas as an√°lises
        roadmap_analysis = self.analyze_roadmap_implementation()
        robustness_analysis = self.analyze_robustness()
        expansion_analysis = self.analyze_expansion_capability()

        # Gerar relat√≥rio
        report = []
        report.append("# üåü RELAT√ìRIO COMPLETO DE ROBUSTEZ - Lore N.A.")
        report.append(f"**Data:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")

        # SE√á√ÉO 1: ADER√äNCIA AO ROADMAP
        report.append("## üìã 1. ADER√äNCIA AO ROADMAP")
        report.append("")

        implemented_count = len(self.implemented_features)
        missing_count = len(self.missing_features)
        total_count = implemented_count + missing_count

        if total_count > 0:
            implementation_percentage = (implemented_count / total_count) * 100
        else:
            implementation_percentage = 0

        report.append(
            f"**Score de Implementa√ß√£o:** {implementation_percentage:.1f}% ({implemented_count}/{total_count})")
        report.append("")

        # Features implementadas
        report.append("### ‚úÖ Funcionalidades IMPLEMENTADAS:")
        for feature in self.implemented_features:
            feature_info = roadmap_analysis.get(feature, {})
            description = feature_info.get('description', feature)
            report.append(f"- **{description}** ‚úÖ")

        if not self.implemented_features:
            report.append("- Nenhuma funcionalidade completamente implementada")

        report.append("")

        # Features ausentes
        report.append("### ‚ùå Funcionalidades AUSENTES:")
        for feature in self.missing_features:
            feature_info = roadmap_analysis.get(feature, {})
            description = feature_info.get('description', feature)
            report.append(f"- **{description}** ‚ùå")

        if not self.missing_features:
            report.append("- Todas as funcionalidades est√£o implementadas!")

        report.append("")

        # SE√á√ÉO 2: ROBUSTEZ 24/7
        report.append("## üõ°Ô∏è 2. ROBUSTEZ PARA EXECU√á√ÉO 24/7")
        report.append("")

        robustness_scores = [criterion["percentage"] for criterion in robustness_analysis.values()]
        avg_robustness = sum(robustness_scores) / len(robustness_scores) if robustness_scores else 0

        report.append(f"**Score de Robustez Geral:** {avg_robustness:.1f}%")
        report.append("")

        for criterion_name, criterion in robustness_analysis.items():
            status = "‚úÖ" if criterion["percentage"] >= 70 else "‚ö†Ô∏è" if criterion["percentage"] >= 40 else "‚ùå"
            report.append(f"- **{criterion['description']}:** {criterion['percentage']:.1f}% {status}")

        report.append("")

        # SE√á√ÉO 3: CAPACIDADE DE EXPANS√ÉO
        report.append("## üöÄ 3. CAPACIDADE DE EXPANS√ÉO")
        report.append("")

        expansion_implemented = sum(1 for factor in expansion_analysis.values() if factor["implemented"])
        expansion_total = len(expansion_analysis)
        expansion_percentage = (expansion_implemented / expansion_total) * 100 if expansion_total > 0 else 0

        report.append(
            f"**Score de Expansibilidade:** {expansion_percentage:.1f}% ({expansion_implemented}/{expansion_total})")
        report.append("")

        for factor_name, factor in expansion_analysis.items():
            status = "‚úÖ" if factor["implemented"] else "‚ùå"
            report.append(f"- **{factor['description']}:** {status}")

            if factor["blockers"]:
                for blocker in factor["blockers"]:
                    report.append(f"  - Bloqueador: {blocker}")

        report.append("")

        # SE√á√ÉO 4: RESPOSTA √ÄS QUEST√ïES PRINCIPAIS
        report.append("## üéØ 4. RESPOSTAS √ÄS QUEST√ïES PRINCIPAIS")
        report.append("")

        # Quest√£o 1: Ideias implementadas?
        report.append("### ‚ùì Todas as ideias da documenta√ß√£o est√£o implementadas?")
        if implementation_percentage >= 80:
            report.append("**RESPOSTA:** ‚úÖ **SIM** - A maioria das ideias est√° implementada")
        elif implementation_percentage >= 60:
            report.append("**RESPOSTA:** ‚ö†Ô∏è **PARCIALMENTE** - Muitas ideias implementadas, algumas ausentes")
        else:
            report.append("**RESPOSTA:** ‚ùå **N√ÉO** - Muitas ideias ainda n√£o foram implementadas")

        report.append("")

        # Quest√£o 2: Robustez para 24/7?
        report.append("### ‚ùì O universo √© robusto para evoluir 24/7?")
        if avg_robustness >= 70:
            report.append("**RESPOSTA:** ‚úÖ **SIM** - Sistema robusto para execu√ß√£o cont√≠nua")
        elif avg_robustness >= 50:
            report.append("**RESPOSTA:** ‚ö†Ô∏è **COM RESSALVAS** - Robusto mas precisa de melhorias")
        else:
            report.append("**RESPOSTA:** ‚ùå **N√ÉO** - Sistema ainda n√£o est√° robusto o suficiente")

        report.append("")

        # Quest√£o 3: Expans√£o durante execu√ß√£o?
        report.append("### ‚ùì √â poss√≠vel expandir o c√≥digo enquanto o universo roda?")
        if expansion_percentage >= 70:
            report.append("**RESPOSTA:** ‚úÖ **SIM** - Sistema preparado para expans√£o em tempo real")
        elif expansion_percentage >= 40:
            report.append("**RESPOSTA:** ‚ö†Ô∏è **LIMITADAMENTE** - Algumas expans√µes poss√≠veis")
        else:
            report.append("**RESPOSTA:** ‚ùå **N√ÉO** - Expans√£o requer parada do sistema")

        report.append("")

        # SE√á√ÉO 5: PR√ìXIMOS PASSOS
        report.append("## üîß 5. PR√ìXIMOS PASSOS RECOMENDADOS")
        report.append("")

        recommendations = []

        # Baseado na robustez
        if avg_robustness < 70:
            recommendations.append(
                "üõ°Ô∏è **Melhorar robustez:** Implementar tratamento de erros e logging em todos os m√≥dulos")

        # Baseado na implementa√ß√£o
        if implementation_percentage < 80:
            recommendations.append("üìã **Completar roadmap:** Implementar funcionalidades ausentes priorit√°rias")

        # Baseado na expans√£o
        if expansion_percentage < 50:
            recommendations.append("üöÄ **Preparar expansibilidade:** Implementar hot reload e sistema de migra√ß√µes")

        # Espec√≠ficos sempre importantes
        recommendations.extend([
            "‚ö° **Otimizar performance:** Implementar cache, paraleliza√ß√£o e algoritmos eficientes",
            "üìä **Implementar analytics:** M√©tricas avan√ßadas de comportamento emergente",
            "ü§ñ **Adicionar IA conversacional:** Integra√ß√£o com modelos de linguagem",
            "üîÑ **Automatizar CI/CD:** Deploy cont√≠nuo e testes automatizados"
        ])

        for i, rec in enumerate(recommendations, 1):
            report.append(f"{i}. {rec}")

        report.append("")
        report.append("---")
        report.append("*Relat√≥rio gerado automaticamente pelo sistema de an√°lise Lore N.A.*")

        return "\\n".join(report)

    def _analyze_file_complexity(self, file_path: Path) -> Dict[str, int]:
        """Analisa complexidade de um arquivo Python"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Contar linhas
            lines = len(content.split('\\n'))

            # Contar fun√ß√µes
            functions = content.count('def ')

            # Contar classes
            classes = content.count('class ')

            return {
                "lines": lines,
                "functions": functions,
                "classes": classes
            }
        except Exception:
            return {"lines": 0, "functions": 0, "classes": 0}

    def _search_concept_in_codebase(self, concepts: List[str]) -> bool:
        """Busca conceitos no c√≥digo"""
        python_files = list(self.src_dir.glob("*.py"))

        for py_file in python_files:
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read().lower()

                for concept in concepts:
                    if concept.lower() in content:
                        return True
            except Exception:
                continue

        return False


def main():
    """Fun√ß√£o principal"""
    print("üåü LORE N.A. - AN√ÅLISE COMPLETA DE ROBUSTEZ E ROADMAP")
    print("=" * 60)

    analyzer = RobustezAnalyzer()

    # Gerar relat√≥rio completo
    report = analyzer.generate_comprehensive_report()

    # Salvar relat√≥rio
    report_file = Path("/home/brendo/lore/docs/reports/ANALISE-ROBUSTEZ-COMPLETA.md")
    report_file.parent.mkdir(parents=True, exist_ok=True)

    with open(report_file, 'w', encoding='utf-8') as f:
        f.write(report)

    print(f"\\n\\nüìÑ Relat√≥rio salvo em: {report_file}")
    print("\\nüéØ RESUMO EXECUTIVO:")
    print("=" * 30)

    # Resumo executivo
    implemented_count = len(analyzer.implemented_features)
    missing_count = len(analyzer.missing_features)
    total_features = implemented_count + missing_count

    if total_features > 0:
        impl_pct = (implemented_count / total_features) * 100
        print(f"üìã Roadmap: {impl_pct:.1f}% implementado ({implemented_count}/{total_features})")

    print(f"‚úÖ Features implementadas: {analyzer.implemented_features}")
    print(f"‚ùå Features ausentes: {analyzer.missing_features}")

    print("\\nüéØ O universo est√° pronto para:")
    print("- ‚úÖ Execu√ß√£o local e demonstra√ß√£o")
    print("- ‚ö†Ô∏è Execu√ß√£o 24/7 (com melhorias)")
    print("- ‚ùå Expans√£o em tempo real (precisa prepara√ß√£o)")


if __name__ == "__main__":
    main()
